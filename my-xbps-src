#!/bin/bash
# vim: set ts=4 sw=4 et:
set -e

# Get cwd of this script
# https://stackoverflow.com/questions/59895/get-the-source-directory-of-a-bash-script-from-within-the-script-itself
cwd="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )" 2>/dev/null
[[ $cwd ]] || exit 123

_chapter() {
    l="------------------------------------------------------------------------------"

    echo $l
    echo -e $@
    echo $l
}

_build_usage() {
    echo '
y - build now
n - do not build
s - skip version
i - ignore package
q - quit
a - build all following updates
d - do not build all following updates
? - print help
    '
}

# Use with || continue
_chapter_question_build() {
    [[ $all = true ]] && return 0
    [[ $all = false ]] && return 1

    echo $l

    while true
    do
        echo -n "$@ [y,n,s,i,q,a,d,?]? "
        read answer

        unset skip ignore all
        case ${answer:0:1} in
            # proceed
            y ) echo ; return 0 ;;
            n ) return 1 ;;
            # proceed with special var
            s ) skip=true ; return 0 ;;
            # proceed with special var
            i ) ignore=true ; return 0 ;;
            q ) echo $l ; exit 0 ;;
            # proceed with special var
            a ) all=true ; echo ; return 0 ;;
            d ) all=false ; return 1 ;;
            * ) _build_usage ;;
        esac
    done

    echo $l
}

# Use with || continue
_chapter_question_build_fail_continue() {
    echo $l

    while true
    do
        echo -n "skip $p update [y,n,q]? "
        read answer

        case ${answer:0:1} in
            y )
                # Skip
                sed -i '/_my_field_skip_version/d' $template
                sed -i "/^_my_field_repo=/a _my_field_skip_version=$upstream_rev" $template
                ;;
            n )
                echo $l
                ;;
            q )
                echo $l
                exit 0
                ;;
            * )
                # Ask again
                continue
                ;;
        esac
        break
    done
}

_create_links_to_my_pkgs() {
    cd $cwd/my-srcpkgs/

    # Remove old ones
    find -L ../srcpkgs/ -maxdepth 1 -type l -exec rm -v {} +

    # Create new ones
    local a
    for a in * ; do
        ln -svn ../my-srcpkgs/$a ../srcpkgs/$a 2>/dev/null || true
    done
}

_update_system() {
    _create_links_to_my_pkgs

    cd $cwd/

    _chapter 'update void-packages'
    git fetch --all --prune
    [[ -z $(git status --untracked-files=no --porcelain) ]] || local do_stash=true
    [[ $do_stash = true ]] && git stash push
    # FIXME hardcode
    git rebase origin/master
    [[ $do_stash = true ]] && git stash pop --index

    _chapter 'update host pkgs'
    sudo vpm up
    sudo vpm ar
    _chapter 'update build env'
    ./xbps-src bootstrap-update
}

# common/xbps-src/shutils/common.sh
_get_subpkgs() {
    local f
    for f in $(typeset -F)
    do
        case "$f" in
            *_package) echo "${f%_package}" ;;
        esac
    done
}

update_my_pkgs() {
    rm -rf $cwd/{hostdir/binpkgs,masterdir/builddir,masterdir/destdir}/
    rm -f /tmp/my-xbps-log

    if [[ $@ ]]
    then
        force=true
        mypkgs=$@
    else
        cd $cwd/my-srcpkgs/
        # Omitting symlinks
        mypkgs=$(find . -maxdepth 1 -mindepth 1 ! -type l -printf '%P\n')
    fi

    _update_system

    local p
    for p in $mypkgs ; do
        # TODO support hg
        [[ $p =~ 'git' ]] && git=true

        unset _my_field_autoinstall _my_field_ignore _my_field_repo _my_field_skip_version
        template=srcpkgs/$p/template
        # FIXME workaround for - vopt_enable: command not found
        . $template 2>/dev/null || true

        [[ $force != true && $_my_field_ignore ]] && continue

        if [[ $git = true ]]
        then
            echo '=> my-xbps-src: checking updates ' $p
            upstream_rev_long=$(git ls-remote $_my_field_repo HEAD | awk '{print $1}')
            upstream_rev=${upstream_rev_long:0:7}
        else
            upstream_rev=$version
        fi

        if [[ $force != true ]]
        then
            if [[ $upstream_rev = $version || $upstream_rev = $_my_field_skip_version ]]
            then
                continue
            fi
        fi

        _chapter_question_build "build $p $upstream_rev" || continue

        if [[ $force != true && $skip = true ]]
        then
            sed -i '/_my_field_skip_version/d' $template
            sed -i "/^_my_field_repo=/a _my_field_skip_version=$upstream_rev" $template
            continue
        elif [[ $force = !true && $ignore = true ]]
        then
            sed -i '/_my_field_ignore/d' $template
            sed -i '/^_my_field_repo=/i _my_field_ignore=1' $template
            continue
        fi

        cp $template /tmp/${p}_old
        if [[ $git = true ]]
        then
            sed "0,/^version/{s/^version=.*/version=$upstream_rev/}" $template > /tmp/${p}_new
        # FIXME this is not needed
        else
            cp $template /tmp/${p}_new
        fi

        # Put previous template on ctrl-c
        trap "
            mv /tmp/${p}_old $template 2>/dev/null || true
            _chapter_question_build_fail_continue
            continue
        " SIGINT

        mv /tmp/${p}_new $template

        # TODO implement noautoinstall
        #[[ $_my_field_autoinstall = false ]] && noautoinstall[$p]=$p

        start=$SECONDS
        if ! ./xbps-src -C pkg $p
        then
            # Put previous template on build fail
            mv /tmp/${p}_old $template 2>/dev/null || true
            _chapter_question_build_fail_continue
            continue
        fi
        end=$SECONDS

        duration=$(( end - start ))
        duration_pretty=$(date -d@${duration} -u +%H:%M:%S)

        built=true

        if [[ $git = true && -e masterdir/builddir/$p-$upstream_rev ]]
        then
            (
                cd masterdir/builddir/$p-$upstream_rev

                l=$(git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset' --abbrev-commit $version..$upstream_rev 2>/dev/null || true)
                if [[ $l ]]
                then
                    echo -e "$p\n\n$l\n\n" >> /tmp/my-xbps-log
                else
                    true
                fi
            )
        fi
    done

    # Show log if not empty
    [[ -e /tmp/my-xbps-log ]] && less /tmp/my-xbps-log

    if [[ $built ]]
    then
        sudo xdowngrade $(find hostdir/binpkgs '!' -name '*-devel-*' '!' -name '*-dbg-*' -name '*.xbps')
    else
        _chapter "nothing to install"
    fi
}

cleanup() {
    cd $cwd/

    _chapter 'update void-packages'
    git fetch --all --prune
    [[ -z $(git status --untracked-files=no --porcelain) ]] || local do_stash=true
    [[ $do_stash = true ]] && git stash push
    # FIXME hardcode
    git rebase origin/master
    [[ $do_stash = true ]] && git stash pop

    _chapter 'perform cleanup'
    ./xbps-src clean
    ./xbps-src clean-repocache
    ./xbps-src remove-autodeps
    ./xbps-src zap
    ./xbps-src binary-bootstrap

    _chapter 'cleanup success'
}

#
# Main switch
#
case $1 in
    up)
        if [[ $2 ]]
        then
            shift
            update_my_pkgs $@
        else
            update_my_pkgs
        fi
        ;;
    cleanup)
        cleanup
        ;;
    *)
        echo "$0: invalid parameter $1"
        exit 1
        ;;
esac
